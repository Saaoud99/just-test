pub use chrono::Utc;
// this will be the structure that wil handle the errors
#[derive(Debug, Eq, PartialEq)]
pub struct FormError {
   pub form_values: (&'static str, String),
   pub date: String,
   pub err: &'static str,
}

impl FormError {
    pub fn new(field_name: &'static str, field_value: String, err: &'static str) -> Self {
        FormError{
            form_values:(field_name , field_value),
            date: Utc::now().format("%Y-%m-%d %H:%M:%S").to_string(),
            err : err
        }
    }
}

#[derive(Debug, Eq, PartialEq)]
pub struct Form {
 pub   name: String,
   pub password: String,
}

impl Form {
    pub fn new(name : String ,password: String) -> Self{
        Form{name: name , password:password}
    }

    pub fn validate(&self) -> Result<(), FormError> {
        let mut checklow = false;
        let mut checknbr = false;
        let mut checkdef= false; 
        
        if self.name.is_empty(){
            return Err(FormError::new("name",self.name.to_string(),"Username is empty")   );
        }

        if self.password.len()>= 8{
            for i in self.password.chars(){
            if i.is_lowercase() || i.is_uppercase(){
                checklow =true
            }
             else
             if i.is_numeric(){
                checknbr = true
            }
            if !i.is_alphanumeric() && !i.is_whitespace() {
                checkdef = true
            }
        }
        }else{
          return  Err(FormError::new("password",self.password.to_string(),"Password should be at least 8 characters long")   );
        }

        if !checklow || !checkdef || !checknbr{
          return  Err(FormError::new("password",self.password.to_string(),"Password should be a combination of ASCII numbers, letters and symbols")   );

        }
        Ok(())
    }
}
